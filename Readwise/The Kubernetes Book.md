# The Kubernetes Book

![rw-book-cover](https://images-na.ssl-images-amazon.com/images/I/41db9ap7UML._SL200_.jpg)

## Metadata
- Author: [[Nigel Poulton]]
- Full Title: The Kubernetes Book
- Category: #books

## Highlights
- The API server The API server is the Grand Central station of Kubernetes. All communication, between all components, must go through the API server. We’ll get into the detail later, but it’s important to understand that internal system components, as well as external user components, all communicate through the API server – all roads lead to the API Server. ([Location 310](https://readwise.io/to_kindle?action=open&asin=B072TS9ZQZ&location=310))
- The cluster store The cluster store is the only stateful part of the control plane and persistently stores the entire configuration and state of the cluster. As such, it’s a vital component of every Kubernetes cluster – no cluster store, no cluster. ([Location 317](https://readwise.io/to_kindle?action=open&asin=B072TS9ZQZ&location=317))
- The controller manager and controllers The controller manager implements all the background controllers that monitor cluster components and respond to events. Architecturally, the controller manager is a controller of controllers, meaning it spawns all the core controllers and monitors them. ([Location 327](https://readwise.io/to_kindle?action=open&asin=B072TS9ZQZ&location=327))
- Some of the core controllers include the Deployment controller, the StatefulSet controller, and the ReplicaSet controller. Each one is responsible for a small subset of cluster intelligence and runs as a background watch-loop constantly watching the API Server for changes. ([Location 329](https://readwise.io/to_kindle?action=open&asin=B072TS9ZQZ&location=329))
- The logic implemented by each controller is as follows, and is at the heart of Kubernetes and declarative design patterns. ([Location 333](https://readwise.io/to_kindle?action=open&asin=B072TS9ZQZ&location=333))
- Terminology: Throughout the book we’ll use terms like controller, control loop, watch loop, and reconciliation loop to mean the same thing. ([Location 338](https://readwise.io/to_kindle?action=open&asin=B072TS9ZQZ&location=338))
- The scheduler At a high level, the scheduler watches the API server for new work tasks and assigns them to appropriate healthy worker nodes. Behind the scenes, it implements complex logic that filters out nodes incapable of running tasks, and then ranks the nodes that are capable. The ranking system is complex, but the node with the highest ranking score is selected to run the task. ([Location 340](https://readwise.io/to_kindle?action=open&asin=B072TS9ZQZ&location=340))
- The cloud controller manager If you’re running your cluster on a supported public cloud platform, such as AWS, Azure, GCP, or Linode, your control plane will be running a cloud controller manager. Its job is to facilitate integrations with cloud services, such as instances, load-balancers, and storage. For example, if your application asks for an internet-facing load-balancer, the cloud controller manager works with the underlying cloud to provision a load-balancer and connect it to your app. ([Location 350](https://readwise.io/to_kindle?action=open&asin=B072TS9ZQZ&location=350))
- Behind the scenes, Deployments, DaemonSets and StatefulSets are implemented as controllers that run as watch loops constantly observing the cluster making sure observed state matches desired state. ([Location 483](https://readwise.io/to_kindle?action=open&asin=B072TS9ZQZ&location=483))
- Contexts group together clusters and users under a friendly name. For example, you might have a context called ops-prod that combines the ops user credentials with the prod cluster definition. If you use kubectl with this context, you’ll be sending commands to the API server of the prod cluster as the ops user. ([Location 678](https://readwise.io/to_kindle?action=open&asin=B072TS9ZQZ&location=678))
- These resources are actually Linux kernel namespaces, and include the following: net namespace: IP address, port range, routing table… pid namespace: isolated process tree mnt namespace: filesystems and volumes… UTS namespace: Hostname IPC namespace: Unix domain sockets and shared memory ([Location 794](https://readwise.io/to_kindle?action=open&asin=B072TS9ZQZ&location=794))
- Pod theory summary Pods are the atomic unit of scheduling in Kubernetes Single-container Pods are the simplest Multi-container Pods are ideal for co-locating tightly coupled workloads and are fundamental to service meshes Pods get scheduled on worker nodes and you can’t schedule a single Pod to span multiple nodes Pods are defined declaratively in manifest files you post to the API server You almost always deploy Pods via higher-level controllers ([Location 841](https://readwise.io/to_kindle?action=open&asin=B072TS9ZQZ&location=841))
