---
aliases: []
confidence: 
created: 2025-02-07T12:57:52Z
epistemic: 
last_reviewed: 
modified: 2025-12-13T11:39:44Z
purpose: 
review_interval: 
see_also: []
source_of_truth: []
status: 
tags: [SDLC]
title: Nightmare pipeline
type:
uid: 
updated: 
version:
---

Our Delivery Pipeline should be an utter nightmare for any defect trying to get through to production.

Any code bold enough to enter our pipeline should have one promise, one truth, on its mind. I am *ready*.

The code should be smashed, bent, torn, and burned to the ground. Dragged to its feet, pulverised, obliterated, driven to its limits, driven insane with torment before rising again clean and pure, certain it can live up to the promise it has made to production. I *am* ready

The pipeline should be cunning in its cataclysmal and annihilatory assault on the code, in its devastating cleansing.

If you were a bug, our pipeline should be the most moiling, ghastly, intimidating and injurious journey of your miserable existence.

It should be disputatious and deleterious, pugnacious and repugnant, treacherous and unlovely.

If a bug makes it through to production it deservers to be there. Well played, possibly null value.

Our code should be of supreme quality; lovely, easy and delightful. If, for any reason, we have to allow poor quality through it should break our hearts, infect our dreams and hound us until we fix it. Which we will.

This is a wonderfully poetic and intense description of what a robust Continuous Integration/Continuous Deployment (CI/CD) pipeline should be. Let me break down the metaphorical significance and practical implications of this artistic take on software quality assurance.

The author portrays the CI/CD pipeline as a trial by fire - a purifying gauntlet that code must survive to prove its worthiness for production. This metaphor is particularly apt because a well-designed CI/CD pipeline should indeed put code through comprehensive testing and validation stages that expose any weaknesses.

The phrase "smashed bent torn and burned to the ground" evokes the intensive nature of proper testing practices. In practical terms, this translates to:

Code Analysis: Static code analysis tools that scrutinize every line for potential issues, "smashing" through superficial appearances to examine the underlying structure.

Comprehensive Testing: The "pulverised, obliterated" imagery suggests thorough unit testing, integration testing, and stress testing that push code to its limits. When code survives this battery of tests, we can be more confident in its reliability.

The description of the pipeline as "cunning in its cataclysmal and annihilatory assault" suggests intelligent test design that anticipates edge cases and potential failure modes. This mirrors the real-world need for thoughtful test coverage that doesn't just check the happy path but actively tries to break the code in creative ways.

The author's statement about bugs - that if they make it through, they "deserve to be there" - is particularly interesting. It acknowledges that no system is perfect while setting an extremely high bar for what constitutes acceptable imperfection. The specific callout to "possibly null value" is a knowing nod to one of programming's most persistent challenges.

The final paragraph about code quality being "lovely, easy and delightful" contrasts beautifully with the violent imagery that preceded it. This reflects an important truth: while the testing process should be brutal, its purpose is to ensure the end product is elegant and reliable. The emotional weight given to allowing poor quality code through - that it should "break our hearts, infect our dreams" - speaks to the professional pride and responsibility that characterizes good development practices.
