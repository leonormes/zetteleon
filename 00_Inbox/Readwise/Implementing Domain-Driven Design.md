# Implementing Domain-Driven Design

![rw-book-cover](https://images-na.ssl-images-amazon.com/images/I/51p16XLhuiL._SL200_.jpg)

## Metadata
- Author: [[Vaughn Vernon]]
- Full Title: Implementing Domain-Driven Design
- Category: #books

## Highlights
- It seems that in software development we are always mapping from one thing to another. We map our objects to databases. We map our objects to the user interface and then back again. We map our objects to and from various application representations, including those that can be consumed by other systems and applications. ([Location 372](https://readwise.io/to_kindle?action=open&asin=B00BCLEBN8&location=372))
- First of all, and sad to say, I think there has been a general abandonment of good design and development practices in the Java community. These days it may be difficult to find a clean, explicit domain model in most Java-based projects. It seems to me that Scrum and other agile techniques are being used as substitutes for careful modeling, where a product backlog is thrust at developers as if it serves as a set of designs. Most agile practitioners will leave their daily stand-up without giving a second thought to how their backlog tasks will affect the underlying model of the business. Although I assume this is needless to say, I must assert that Scrum, for example, was never meant to stand in place of design. No matter how many project and product managers would like to keep you marching on a relentless path of continuous delivery, Scrum was not meant only as a means to keep Gantt chart enthusiasts happy. Yet, it has become that in so many cases. ([Location 494](https://readwise.io/to_kindle?action=open&asin=B00BCLEBN8&location=494))
- I need to add that at the time of this writing there was a significant shift toward interest in using document-based and key-value storage over relational databases. This is for good reason, for even Martin Fowler has aptly nicknamed these “aggregate-oriented storage.” ([Location 509](https://readwise.io/to_kindle?action=open&asin=B00BCLEBN8&location=509))
- It’s all part of the ongoing friction created by technology trends, and the friction needs to happen in order for positive change to happen. ([Location 521](https://readwise.io/to_kindle?action=open&asin=B00BCLEBN8&location=521))
    - Note: As we develop ideas on how best to architect code solutions there are many disagrements and opinions. Thought they can be annoying and counter productive, they are a necessary part of maturing
- Early on I take you through one of the pillars of DDD, the Ubiquitous Language (1). A Ubiquitous Language is applicable within a single Bounded Context (2). Straightaway, you need to familiarize yourself with that critical domain modeling mindset. Just remember that whichever way your software models are designed tactically, strategically you’ll want them to reflect the following: a clean Ubiquitous Language modeled in an explicitly Bounded Context. ([Location 599](https://readwise.io/to_kindle?action=open&asin=B00BCLEBN8&location=599))
- Sometimes we may be tempted to place too much emphasis on architecture rather than focusing on the importance of carefully crafting a DDD-based model. Architecture is important, but architectural influences come and go. Remember to prioritize correctly, placing more emphasis on the domain model, which has greater business value and will be more enduring. ([Location 619](https://readwise.io/to_kindle?action=open&asin=B00BCLEBN8&location=619))
    - Note: What is a domain model?
- One of the worst disconnects of a business software development effort is seen in the gap between domain experts and software developers. Generally speaking, true domain experts are focused on delivering business value. On the other hand, software developers are typically drawn to technology and technical solutions to business problems. It’s not that software developers have wrong motivations; it’s just what tends to grab their attention. Even when software developers engage with domain experts, the collaboration is largely at a surface level, and the software that gets developed often results in a translation/mapping between how the business thinks and operates and how the software developer interprets that. The resulting software generally does not reflect a recognizable realization of the mental model of the domain experts, or perhaps it does so only partially. Over time this disconnect becomes costly. The translation of domain knowledge into software is lost as developers transition to other projects or leave the company. ([Location 805](https://readwise.io/to_kindle?action=open&asin=B00BCLEBN8&location=805))
